name: Release version
run-name: Release version (${{ github.event.inputs.increment }})

on:
  workflow_dispatch:
    inputs:
      increment:
        type: choice
        description: Semantic versioning increment type
        options:
          - major
          - minor
          - patch
        required: true
        default: patch

jobs:
  release:
    name: Release version (${{ github.event.inputs.increment }})
    runs-on: ubuntu-latest

    if: github.ref_name == 'main'

    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          fetch-tags: true
          ssh-key: '${{ secrets.VERSION_RELEASE_DEPLOYMENT_KEY }}'

      - name: Setup git
        run: |
          git config user.name github-actions
          git config user.email github-actions@github.com

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: latest

      - name: Bump up ${{ github.event.inputs.increment }} version
        id: increment_version
        env:
          INCREMENT: ${{ github.event.inputs.increment }}
        run: |
          # Get current version before bumping
          CURRENT_VERSION=$(git tag --sort=-v:refname | head -n 1)
          
          # Bump version
          VERSION=$(pnpm version "$INCREMENT" --no-git-tag-version)
          echo "New version: $VERSION"
          echo "new-version=$VERSION" >> $GITHUB_OUTPUT
          
          # Function to categorize commits
          categorize_commit() {
            local message="$1"
            local hash="$2"
            local msg_lower=$(echo "$message" | tr '[:upper:]' '[:lower:]')
            
            if echo "$msg_lower" | grep -qE '^(feat|feature|add)'; then
              echo "Added|$message|$hash"
            elif echo "$msg_lower" | grep -qE '^(fix|bugfix|hotfix)'; then
              echo "Fixed|$message|$hash"
            elif echo "$msg_lower" | grep -qE '^(update|change|modify|refactor|improve)'; then
              echo "Changed|$message|$hash"
            elif echo "$msg_lower" | grep -qE '^(remove|delete)'; then
              echo "Removed|$message|$hash"
            elif echo "$msg_lower" | grep -qE '^(deprecate)'; then
              echo "Deprecated|$message|$hash"
            elif echo "$msg_lower" | grep -qE '^(security|vuln)'; then
              echo "Security|$message|$hash"
            else
              if echo "$msg_lower" | grep -qE '(add|new|create|implement)'; then
                echo "Added|$message|$hash"
              elif echo "$msg_lower" | grep -qE '(fix|repair|resolve|correct)'; then
                echo "Fixed|$message|$hash"
              elif echo "$msg_lower" | grep -qE '(update|change|modify|refactor|improve)'; then
                echo "Changed|$message|$hash"
              elif echo "$msg_lower" | grep -qE '(remove|delete)'; then
                echo "Removed|$message|$hash"
              else
                echo "Changed|$message|$hash"
              fi
            fi
          }
          
          # Get commits and categorize them
          if [ -z "$CURRENT_VERSION" ]; then
            echo "No previous tag found, using all commits"
            RAW_COMMITS=$(git log --format="%s|%h" --no-merges)
          else
            echo "Previous tag: $CURRENT_VERSION"
            RAW_COMMITS=$(git log "${CURRENT_VERSION}..HEAD" --format="%s|%h" --no-merges)
          fi
          
          # Categorize commits
          declare -A CATEGORIZED
          while IFS='|' read -r message hash; do
            result=$(categorize_commit "$message" "$hash")
            category=$(echo "$result" | cut -d'|' -f1)
            CATEGORIZED[$category]+="- ${message} (${hash})"$'\n'
          done <<< "$RAW_COMMITS"
          
          # Build changelog sections in order
          CHANGELOG_SECTIONS=""
          for category in "Added" "Changed" "Deprecated" "Removed" "Fixed" "Security"; do
            if [ -n "${CATEGORIZED[$category]}" ]; then
              CHANGELOG_SECTIONS+="### ${category}"$'\n'
              CHANGELOG_SECTIONS+="${CATEGORIZED[$category]}"$'\n'
            fi
          done
          
          # Get current date
          RELEASE_DATE=$(date +%Y-%m-%d)
          
          # Create the new changelog entry
          NEW_ENTRY="## [${VERSION#v}] - ${RELEASE_DATE}

          ${CHANGELOG_SECTIONS}"
          
          # Update CHANGELOG.md - replace [Unreleased] section with new version and add empty [Unreleased]
          if [ -f CHANGELOG.md ]; then
            # Create temporary file with updated changelog
            awk -v new_entry="$NEW_ENTRY" '
              /^## \[Unreleased\]/ {
                print $0
                print ""
                print new_entry
                # Skip content until next version header
                in_unreleased = 1
                next
              }
              /^## \[/ && in_unreleased {
                in_unreleased = 0
              }
              !in_unreleased { print }
            ' CHANGELOG.md > CHANGELOG.md.tmp
            mv CHANGELOG.md.tmp CHANGELOG.md
          else
            echo "Warning: CHANGELOG.md not found"
          fi
          
          # Commit version bump and changelog together
          git add package.json CHANGELOG.md
          git commit -m "${VERSION}"
          git tag "${VERSION}"

      - name: Push new version ${{ steps.increment_version.outputs.new-version }}
        run: git push --follow-tags

      - name: Generate release notes
        id: generate_notes
        env:
          VERSION: ${{ steps.increment_version.outputs.new-version }}
        run: |
          # Function to categorize commits
          categorize_commit() {
            local message="$1"
            local hash="$2"
            local msg_lower=$(echo "$message" | tr '[:upper:]' '[:lower:]')
            
            if echo "$msg_lower" | grep -qE '^(feat|feature|add)'; then
              echo "Added|$message|$hash"
            elif echo "$msg_lower" | grep -qE '^(fix|bugfix|hotfix)'; then
              echo "Fixed|$message|$hash"
            elif echo "$msg_lower" | grep -qE '^(update|change|modify|refactor|improve)'; then
              echo "Changed|$message|$hash"
            elif echo "$msg_lower" | grep -qE '^(remove|delete)'; then
              echo "Removed|$message|$hash"
            elif echo "$msg_lower" | grep -qE '^(deprecate)'; then
              echo "Deprecated|$message|$hash"
            elif echo "$msg_lower" | grep -qE '^(security|vuln)'; then
              echo "Security|$message|$hash"
            else
              if echo "$msg_lower" | grep -qE '(add|new|create|implement)'; then
                echo "Added|$message|$hash"
              elif echo "$msg_lower" | grep -qE '(fix|repair|resolve|correct)'; then
                echo "Fixed|$message|$hash"
              elif echo "$msg_lower" | grep -qE '(update|change|modify|refactor|improve)'; then
                echo "Changed|$message|$hash"
              elif echo "$msg_lower" | grep -qE '(remove|delete)'; then
                echo "Removed|$message|$hash"
              else
                echo "Changed|$message|$hash"
              fi
            fi
          }
          
          # Get the previous tag
          PREVIOUS_TAG=$(git tag --sort=-v:refname | grep -v "^${VERSION}$" | head -n 1)
          
          # Get commits and categorize them
          if [ -z "$PREVIOUS_TAG" ]; then
            echo "No previous tag found, using all commits"
            RAW_COMMITS=$(git log --format="%s|%h" --no-merges)
          else
            echo "Previous tag: $PREVIOUS_TAG"
            RAW_COMMITS=$(git log "${PREVIOUS_TAG}..${VERSION}" --format="%s|%h" --no-merges)
          fi
          
          # Categorize commits
          declare -A CATEGORIZED
          while IFS='|' read -r message hash; do
            if [ -n "$message" ]; then
              result=$(categorize_commit "$message" "$hash")
              category=$(echo "$result" | cut -d'|' -f1)
              CATEGORIZED[$category]+="- ${message} (${hash})"$'\n'
            fi
          done <<< "$RAW_COMMITS"
          
          # Build changelog sections in order
          CHANGELOG_SECTIONS=""
          for category in "Added" "Changed" "Deprecated" "Removed" "Fixed" "Security"; do
            if [ -n "${CATEGORIZED[$category]}" ]; then
              CHANGELOG_SECTIONS+="### ${category}"$'\n'
              CHANGELOG_SECTIONS+="${CATEGORIZED[$category]}"$'\n'
            fi
          done
          
          # Create release notes
          RELEASE_NOTES="## Changes

          ${CHANGELOG_SECTIONS}
          **Full Changelog**: https://github.com/${{ github.repository }}/compare/${PREVIOUS_TAG}...${VERSION}"
          
          # Save to file for multiline content
          echo "$RELEASE_NOTES" > release_notes.md
          echo "notes-file=release_notes.md" >> $GITHUB_OUTPUT

      - name: Publish new version ${{ steps.increment_version.outputs.new-version }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          VERSION: ${{ steps.increment_version.outputs.new-version }}
        run: |
          gh release create "${VERSION}" \
            --title "Release ${VERSION}" \
            --notes-file "${{ steps.generate_notes.outputs.notes-file }}"
